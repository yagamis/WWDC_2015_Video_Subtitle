1
00:00:21,356 --> 00:00:22,976
>> CHRIS LATTNER:李宏宇-翻译 
欢迎来到 What's New in Swift.


2
00:00:23,516 --> 00:00:28,596
(掌声)


3
00:00:29,096 --> 00:00:30,096
我是克里斯Lattner。


4
00:00:30,096 --> 00:00:31,886
我将开始这个谈话


5
00:00:31,886 --> 00:00:33,656
和我的同事John McCall将带你


6
00:00:33,656 --> 00:00:35,696
through the second half to
take you through what's new.


7
00:00:36,626 --> 00:00:38,776
在我们出发之前,我认为这将是有趣的


8
00:00:38,776 --> 00:00:41,466
或有帮助的看看我们想做什么。


9
00:00:41,556 --> 00:00:44,456
有什么目标和 Swift2背后的哲学是什么?



10
00:00:45,426 --> 00:00:47,536
我们有三大事情
我们正在努力.


11
00:00:48,276 --> 00:00:49,936
第一, 基本原理.


12
00:00:50,356 --> 00:00:53,036
我们想要的核心功能和核心的行为


13
00:00:53,036 --> 00:00:55,146
是伟大的语言和工具


14
00:00:55,846 --> 00:00:58,696
很多这是看你的反馈，


15
00:00:58,696 --> 00:01:01,276
许多生产过程中使用 Swift.


16
00:01:01,616 --> 00:01:06,996
所以很多这是 --


17
00:01:06,996 --> 00:01:09,756
我想谢谢你所有的反馈。

18
00:01:10,156 --> 00:01:11,856
我们正在继续塑造 Swift


19
00:01:12,276 --> 00:01:14,686
通过所有伟大的反馈使用它的生产商。.


20
00:01:15,916 --> 00:01:17,266
第二是安全


21
00:01:18,096 --> 00:01:20,236
安全是Swift的核心价值.


22
00:01:21,326 --> 00:01:24,466
我们真的希望它是容易编写安全代码默认情况下,

23
00:01:24,896 --> 00:01:26,466
和我们认为新的可用性

24
00:01:26,466 --> 00:01:29,396
在错误处理结构将成为一个伟大的新方法


25
00:01:29,396 --> 00:01:30,006
要做到这一点.


26
00:01:30,776 --> 00:01:32,086
第三,美丽.


27
00:01:33,086 --> 00:01:34,516
我们希望您的代码是美丽的。

28
00:01:34,966 --> 00:01:38,156
作为程序员,我们一直处理代码


29
00:01:38,316 --> 00:01:40,006
这是对我们非常重要。


30
00:01:40,386 --> 00:01:42,536
我们为Swift增加了新事物使其更容易


31
00:01:42,536 --> 00:01:44,776
编写更美丽和自然的代码。


32
00:01:45,836 --> 00:01:48,706
今天我们将为Swift讨论五个新事物.


33
00:01:50,816 --> 00:01:53,246
之前我们得到深入的 what's new in Swift 2,


34
00:01:53,246 --> 00:01:54,136
我认为重要的是要指出


35
00:01:54,136 --> 00:01:57,146
Swift 1.2也是一个巨大的更新。


36
00:01:57,146 --> 00:01:58,976
这只是三个月前被释放.


37
00:01:59,606 --> 00:02:01,846
由于时间的限制,我们没有时间


38
00:02:01,846 --> 00:02:02,896
谈论它。


39
00:02:02,896 --> 00:02:04,926
但是如果你感兴趣,你没见过它了,


40
00:02:04,926 --> 00:02:07,686
查看Swift编程语言的书


41
00:02:08,116 --> 00:02:09,526
和 Xcode 6版本说明。

42
00:02:10,666 --> 00:02:12,446
就让我们一探究竟吧,谈谈基本面.


43
00:02:13,656 --> 00:02:16,956
基本面是精炼的核心行为语言

44
00:02:16,956 --> 00:02:18,366
和它是如何工作的.


45
00:02:19,026 --> 00:02:20,626
所以这里有很多小事情.


46
00:02:20,626 --> 00:02:23,806
这感觉有点随机漫步,但我坚持.


47
00:02:24,526 --> 00:02:25,586
我们将开始讨论enums.


48
00:02:26,796 --> 00:02:29,656
Enums是Swift的最好的特性之一。


49
00:02:29,656 --> 00:02:33,156
在这里我有一个enums，列举一些常见的家庭宠物


50
00:02:33,686 --> 00:02:37,656
Enums是伟大的,因为他们简单的定义和使用。


51
00:02:38,666 --> 00:02:41,656
另一方面,如果你在操场上与他们玩


52
00:02:41,656 --> 00:02:44,906
或打印一个,你可能已经离开了希望.


53
00:02:46,306 --> 00:02:49,036
In Swift 2, enums
现在携带足够的反射信息,


54
00:02:49,036 --> 00:02:50,466
你可以打印它们,
和他们工作得很好


55
00:02:51,516 --> 00:02:56,546
(掌声)


56
00:02:57,046 --> 00:02:58,096
>> CHRIS LATTNER: 接下来,
关联值。


57
00:02:59,056 --> 00:03:01,686
Enums也很好，因为他们是完美的模型 



58
00:03:01,686 --> 00:03:04,126
因为歧视联盟,这个是伟大的


59
00:03:04,126 --> 00:03:07,266
当你有两个不同价值的类型


60
00:03:07,266 --> 00:03:08,796
你想要存储一个东西.


61
00:03:09,706 --> 00:03:12,086
对吗?联盟的价值是非常强大的, 
可能你去了

62
00:03:12,086 --> 00:03:14,826
并试图写的明显的类型。

63
00:03:15,446 --> 00:03:17,716
这是一个完美的模型,但是当你去

64
00:03:17,716 --> 00:03:20,796
使用它,你有这样令人沮丧的事情.


65
00:03:22,076 --> 00:03:24,586
这是非常难过的,我们都这样。


66
00:03:24,716 --> 00:03:26,816
现在Swift 2可以很好地工作。


67
00:03:27,516 --> 00:03:32,546
(掌声)


68
00:03:33,046 --> 00:03:34,836
>> CHRIS LATTNER: 让我们谈谈递归。


69
00:03:34,836 --> 00:03:37,386
事实上，Enums在wift是代数数据类型,


70
00:03:37,596 --> 00:03:38,666
和其他语言一样,


71
00:03:38,666 --> 00:03:41,726
递归代数数据类型是非常强大的。


72
00:03:41,726 --> 00:03:42,846
你可以做一些真正伟大的事情。


73
00:03:42,846 --> 00:03:44,966
在Swift的问题,


74
00:03:45,016 --> 00:03:47,096
一个enum的价值存储内联。

75
00:03:47,766 --> 00:03:49,246
这意味着如果你有一个递归的enum,


76
00:03:49,406 --> 00:03:51,966 
它有一个无限的大小,这是很难的，


77
00:03:51,966 --> 00:03:53,536
我们当前的设备。


78
00:03:53,706 --> 00:03:54,296
也许明年。



79
00:03:55,086 --> 00:03:58,386
有解决方法。


80
00:03:58,386 --> 00:04:02,006
每个人都有可能看到box-type


81
00:04:02,006 --> 00:04:04,166
你可以变成一个参考,但打破模式匹配,


82
00:04:04,166 --> 00:04:05,236
它是丑陋和可怕的。


83
00:04:05,776 --> 00:04:08,196
对于Swift 2,有一个更好的办法。

84
00:04:08,606 --> 00:04:10,796
它没有进入beta 1,


85
00:04:10,976 --> 00:04:11,946
但是很快你就可以


86
00:04:11,946 --> 00:04:14,116
标记您的情况下间接允许你

87
00:04:14,116 --> 00:04:16,656
这种自然的表达,和很好的模式相匹的工作



88
00:04:17,185 --> 00:04:20,125
让我们继续讨论范围[掌声].


89
00:04:24,006 --> 00:04:26,546
>> CHRIS LATTNER: 所以有时候你有一个名字


90
00:04:26,546 --> 00:04:28,356
你想要重用或者你有


91
00:04:28,356 --> 00:04:29,756
确保提前释放的办法。

92
00:04:30,836 --> 00:04:32,976
我们已经提出了一个新的循环语句让你


93
00:04:33,186 --> 00:04:34,806
介绍一个明确的范围.


94
00:04:35,546 --> 00:04:38,816
在这种情况下,我们都有应对互联网巨魔


95
00:04:38,866 --> 00:04:40,906
但是我们尽量保持他们


96
00:04:40,906 --> 00:04:42,836
尽可能紧密绑定。


97
00:04:42,836 --> 00:04:44,866
做的是真正重要的,

98
00:04:44,866 --> 00:04:46,146
当我们把错误处理后在说话

99
00:04:46,766 --> 00:04:50,016
但是做一个关键词导致一些潜在的歧义。


100
00:04:50,326 --> 00:04:52,046
这不是模棱两可的编译器，


101
00:04:52,146 --> 00:04:53,966
模棱两可当我们读代码.


102
00:04:54,896 --> 00:04:57,306
你不要总是看到底部的一个长语句

103
00:04:57,306 --> 00:04:58,546
和我们有一个While循环。


104
00:04:59,856 --> 00:05:03,736
能使其得到真正的,


105
00:05:03,736 --> 00:05:08,026
只是看它所声明的介绍人

106
00:05:08,396 --> 00:05:09,676
我们希望能使其得到真正的什么东西

107
00:05:09,676 --> 00:05:11,576
通过查看介绍人字的声明。

108
00:05:12,026 --> 00:05:15,646
所以我们已经做While循环,
并将它重命名为重复。


109
00:05:15,646 --> 00:05:18,866
您可以立即告诉从顶部,它是一个循环,

110
00:05:18,996 --> 00:05:19,966
这真的很容易[掌声]。


111
00:05:20,336 --> 00:05:25,816
>> CHRIS LATTNER: 让我们谈谈选项集。


112
00:05:26,456 --> 00:05:29,546
选择集是一个轻量级,超高效率的方式


113
00:05:29,546 --> 00:05:31,186
来表示一组布尔值。
114
00:05:31,836 --> 00:05:33,786
你可能已经看到他们如果你曾与各种Cocoa api,


115
00:05:33,786 --> 00:05:36,886
你使用看到看到像语法或在一起。

116
00:05:37,796 --> 00:05:39,786
这样的基本语法实际上很不错。


117
00:05:40,146 --> 00:05:43,496
问题是,当你得到你最终使用的其他语法,

118
00:05:43,496 --> 00:05:45,616
这少一点为好。

119
00:05:45,776 --> 00:05:48,066
你创建一个empty-option设置为零--


120
00:05:48,066 --> 00:05:50,296
它是没有意义的,因为选项集

121
00:05:50,296 --> 00:05:52,466
和可选的是完全不同的概念

122
00:05:52,466 --> 00:05:53,616
和他们合并在一起。

123
00:05:54,186 --> 00:05:57,006
您提取的位操作,这是一个痛苦

124
00:05:57,006 --> 00:06:00,836
和超级容易出错,你可以很容易出错。


125
00:06:00,886 --> 00:06:02,796
Swift 2我们已经选择集 --


126
00:06:02,876 --> 00:06:06,596
这是更糟的是,因为Swift 1.2拥有一批一流的类型


127
00:06:06,596 --> 00:06:09,326
现在所有这一切的结合

128
00:06:09,326 --> 00:06:12,006
使得C选项集看起来像一个古老的倒退


129
00:06:12,556 --> 00:06:13,696
它们[笑]。

130
00:06:15,726 --> 00:06:16,806
>> CHRIS LATTNER: 但是Swift 2解决了这个问题.


131
00:06:16,806 --> 00:06:18,166
它使设置选项集。


132
00:06:18,866 --> 00:06:20,926
这意味着选择集和集现在组成由

133
00:06:20,926 --> 00:06:21,686
方括号

134
00:06:22,226 --> 00:06:24,236
T这意味着你得到空集与一组空的方括号


135
00:06:24,236 --> 00:06:27,566
你获得全套的标准API


136
00:06:27,566 --> 00:06:28,906
使用选项集


137
00:06:28,906 --> 00:06:30,766
它是supereasy和伟大的。


138
00:06:31,516 --> 00:06:36,556
(掌声)

139
00:06:37,056 --> 00:06:37,496
>> CHRIS LATTNER:
现在，它也是美好的


140
00:06:37,496 --> 00:06:39,186
因为你可以定义自己的选项设置

141
00:06:39,186 --> 00:06:40,226
在一个更简单的方法了。

142
00:06:40,956 --> 00:06:43,266
现在所有你要做的就是定义您自己的设置类型,

143
00:06:43,456 --> 00:06:48,696
或结构类型,结构类型为你设置,


144
00:06:48,696 --> 00:06:53,086
并让它符合新选项设置类型的协议，
find storage


145
00:06:53,086 --> 00:06:55,916
发现存储来保存你的位,对你的选择和定义

146
00:06:55,916 --> 00:06:57,206
你想要的元素集。

147
00:06:58,366 --> 00:06:59,956
只有一个简单的定义,


148
00:06:59,956 --> 00:07:01,956
现在让我们谈论的所有语法。

149
00:07:02,576 --> 00:07:04,386
过冷的东西,

150
00:07:04,386 --> 00:07:05,966
它不需要任何编译器匹配。

151
00:07:06,246 --> 00:07:07,726
这个过程是自动完成的


152
00:07:07,966 --> 00:07:10,276
通过一个新功能叫做默认实现

153
00:07:10,276 --> 00:07:13,816
和协议提供的选项设置类型。

154
00:07:13,936 --> 00:07:16,496
我们没有时间谈论默认实现


155
00:07:16,496 --> 00:07:19,596
和详细的协议,但我们有一个会议

156
00:07:19,596 --> 00:07:21,566
讨论协议深深得进入它。

157
00:07:21,566 --> 00:07:22,156
它是好的

158
00:07:23,276 --> 00:07:26,956
让我们谈谈函数和方法

159
00:07:27,416 --> 00:07:30,206
Swift一同结合了函数和方法


160
00:07:30,206 --> 00:07:31,456
成为一个单一的函数声明。

161
00:07:31,866 --> 00:07:36,046
这是一个伟大的事情,两个完全不同的概念


162
00:07:36,046 --> 00:07:38,836
在类型系统成一个美丽的功能的核心。


163
00:07:39,576 --> 00:07:42,056
这个美丽的核心功能是一个关键的一部分,

164
00:07:42,236 --> 00:07:44,236
Swift立即崩溃

165
00:07:44,236 --> 00:07:46,776
当你试图调用这些东西,因为他们采取不同的


166
00:07:46,776 --> 00:07:48,956
参数标签。

167
00:07:48,956 --> 00:07:50,926
这是一个很多人的巨大痛苦。

168
00:07:51,046 --> 00:07:53,836
如果我们看看这些是从哪里来的,


169
00:07:53,976 --> 00:07:56,626
Swift是在objective - c的先例。


170
00:07:57,246 --> 00:07:58,806
C没有参数标签,


171
00:07:59,076 --> 00:08:00,886
参数标签superimportant方法

172
00:08:00,886 --> 00:08:02,766
在objective - c中, 
Swift


173
00:08:04,006 --> 00:08:06,116
Swift 2, 我们固定这个等等。

174
00:08:06,946 --> 00:08:10,396
现在函数和方法有相同的声明语法,

175
00:08:10,966 --> 00:08:12,326
他们以同样的方式工作。

176
00:08:13,866 --> 00:08:15,646
现在当你调用一个全局函数

177
00:08:15,646 --> 00:08:19,826
您提供默认参数标签。

178
00:08:19,826 --> 00:08:20,826
一切都是统一的。

179
00:08:21,516 --> 00:08:25,686
(掌声)

180
00:08:26,186 --> 00:08:27,446
>> CHRIS LATTNER:所以知道这里的关键一点是


181
00:08:27,446 --> 00:08:29,226
这会影响 Swift 代码。

182
00:08:29,226 --> 00:08:30,866
如果你声明一个全局函数在Swift,


183
00:08:30,866 --> 00:08:32,155
默认你这种行为.


184
00:08:33,256 --> 00:08:35,506
函数从C进口继续以同样的方式

185
00:08:35,506 --> 00:08:38,466
表现他们总是因为参数名称


186
00:08:38,466 --> 00:08:40,576
不是API的一部分

187
00:08:40,576 --> 00:08:42,166
和不考虑API。

188
00:08:43,006 --> 00:08:45,416
但今后我们喜欢Swift代码

189
00:08:45,416 --> 00:08:46,936
包括参数标签功能。


190
00:08:47,786 --> 00:08:49,386
如果你在这儿怎么了看起来更深,
191
00:08:49,386 --> 00:08:51,716
甚至还有更多

192
00:08:52,676 --> 00:08:55,216
快速功能参数,

193
00:08:55,526 --> 00:08:58,566
参数可以为每个值有两个不同的名称。.


194
00:08:58,566 --> 00:09:01,816
所以当你声明一些语法的东西,

195
00:09:02,066 --> 00:09:03,636
实际上，你这是默认行为。


196
00:09:04,676 --> 00:09:08,266
两个名字,一个参数可以是一个外部名称


197
00:09:08,266 --> 00:09:10,476
调用者看到的内部名称

198
00:09:10,476 --> 00:09:11,626
实现看到。


199
00:09:12,226 --> 00:09:16,406
默认情况下,第一个参数没有标签显示


200
00:09:16,406 --> 00:09:19,476
外部客户端,有一个名字你可能使用

201
00:09:19,476 --> 00:09:20,426
当你实现这种方法时。

202
00:09:21,506 --> 00:09:24,656
同样的,第二个,后来所以默认参数

203
00:09:24,656 --> 00:09:26,396
成为了内部和外部的

204
00:09:26,396 --> 00:09:28,356
这就是为什么你看到这种行为


205
00:09:28,356 --> 00:09:30,506
有一个论点标签的参数。

206
00:09:31,236 --> 00:09:32,556
这种模式的好处是

207
00:09:32,556 --> 00:09:35,486
当你理解这一点,你可以定制它。

208
00:09:35,486 --> 00:09:39,236
例如,在本例中,它将有意义有一个标签,


209
00:09:39,236 --> 00:09:42,126
第一个参数,你知道它是什么。

210
00:09:42,126 --> 00:09:44,936
你可以仅仅通过复制这一观点的名字。


211
00:09:45,026 --> 00:09:45,646
它是简单的


212
00:09:46,316 --> 00:09:47,896
同样,如果你想删除一些东西,

213
00:09:47,896 --> 00:09:50,996
您可以显式地设置,

214
00:09:50,996 --> 00:09:52,286
强调说删除这个论点标签。


215
00:09:52,926 --> 00:09:54,576
在这样做的时候,我们犯了

216
00:09:54,576 --> 00:09:56,816
一个最令人发指的罪行的命名

217
00:09:56,816 --> 00:09:58,216
通过一个 Boolean没有标签.


218
00:09:58,966 --> 00:10:05,386
跟着我!更好的事情,整个变化,

219
00:10:05,386 --> 00:10:07,886
这使得标签系统中更为突出。

220
00:10:07,886 --> 00:10:10,346
这是是友好的伟大api使用,

221
00:10:10,346 --> 00:10:13,916
意味着我们可以简化大量的复杂性。

222
00:10:14,386 --> 00:10:16,126
所以现在函数和方法是相同的工作,

223
00:10:16,126 --> 00:10:18,116
是我们也可以摆脱特别规定

224
00:10:18,116 --> 00:10:20,736
为默认参数和怪异的英镑的语法,

225
00:10:20,736 --> 00:10:23,146
没有人记得它做了什么,所以现在也消失了。

226
00:10:23,146 --> 00:10:24,046
它是更好的

227
00:10:25,776 --> 00:10:28,586
我们将讨论编译器和谈论这些警告

228
00:10:28,586 --> 00:10:32,036
和编译器编译的错误消息。

229
00:10:32,036 --> 00:10:33,816
这是合理的代码的代码,


230
00:10:33,816 --> 00:10:35,296
也许你已经写过这样的事情,

231
00:10:35,296 --> 00:10:37,646
我想更新一个点。

232
00:10:37,826 --> 00:10:39,426
你给这个Swift 1编译器,


233
00:10:39,426 --> 00:10:41,016
你就能做出这样的事情。

234
00:10:41,476 --> 00:10:45,736
我了解你,但这并不是帮助。


235
00:10:45,996 --> 00:10:48,436
Swift 1.2 是这个更好点.


236
00:10:48,436 --> 00:10:52,076
实际上做出了错误消息告诉我,

237
00:10:52,076 --> 00:10:53,066
有一个问题。

238
00:10:53,156 --> 00:10:55,756
现在我看到,事实上我不能分配。

239
00:10:56,156 --> 00:10:57,636
当然,这还不够好。

240
00:10:57,796 --> 00:10:59,666
我们继续投资生成的错误消息

241
00:10:59,666 --> 00:11:01,116
和警告在编译器

242
00:11:01,476 --> 00:11:04,136
Swift 2 它说,嘿,你不能分配给x


243
00:11:04,136 --> 00:11:05,576
因为自己是不可变的。


244
00:11:06,106 --> 00:11:08,646
和Xcode会告诉你,你可以修复这个问题,

245
00:11:08,696 --> 00:11:10,256
通过标记和变异方法。

246
00:11:11,186 --> 00:11:13,346
我认为很多人这是一个很好的方式 --


247
00:11:13,346 --> 00:11:15,626
它将帮助许多人更好地理解可变性模型


248
00:11:15,626 --> 00:11:17,976
Swift 导致更好的代码。


249
00:11:18,516 --> 00:11:24,546
(掌声)

250
00:11:25,046 --> 00:11:26,406
>> CHRIS LATTNER:当然,这只是一个例子。


251
00:11:26,406 --> 00:11:27,286
这有很多了


252
00:11:27,676 --> 00:11:31,546
警告我们添加的另一个例子是

253
00:11:31,546 --> 00:11:34,806
如果你有一个变量,这个变量可以声明为一个常数,

254
00:11:34,806 --> 00:11:37,466
我们现在生产一个警告,说,嗨,使用让代替。


255
00:11:37,936 --> 00:11:40,196
Swift也自动移动大量的代码


256
00:11:40,196 --> 00:11:42,806
在许多情况下让代替使用。

257
00:11:42,806 --> 00:11:45,856
我们将警告如果你申报价值,

258
00:11:45,856 --> 00:11:47,716
让或,但不要使用它。


259
00:11:48,266 --> 00:11:51,036
我们甚至警告如果您使用一个功能方法

260
00:11:51,896 --> 00:11:53,976
然后忽视结果,

261
00:11:53,976 --> 00:11:56,286
因为你可能想使用一个就地变异方法相反,


262
00:11:56,466 --> 00:11:57,846
我们对那些可以产生警告。

263
00:11:58,036 --> 00:12:01,716
这些都是简单的例子。

264
00:12:02,366 --> 00:12:05,746
让我们谈谈SDK。


265
00:12:05,746 --> 00:12:08,816
Swift的核心部分,它是如何工作的Cocoa.


266
00:12:09,076 --> 00:12:10,936
与普通的objective - c api,


267
00:12:11,256 --> 00:12:13,976
快速编译器不知道是否可以为空指针

268
00:12:13,976 --> 00:12:16,206
以及集合的元素类型是什么。

269
00:12:16,866 --> 00:12:18,446
我们引入了大量的新特性表达

270
00:12:18,446 --> 00:12:21,276
objective - c包括表达能力nullability objective - c

271
00:12:21,656 --> 00:12:24,746
和集合的元素类型。。


272
00:12:25,396 --> 00:12:27,616
还有一大堆其他的特性,

273
00:12:28,136 --> 00:12:31,126
使一个伟大的经验在Swiftobjective - c代码。


274
00:12:31,956 --> 00:12:34,706
框架,最好的消息是,

275
00:12:34,706 --> 00:12:37,996
苹果的工程师们所做的一个非凡的工作采用
所有这些现代objective - c的特性
276
00:12:37,996 --> 00:12:42,176
跨所有平台和CocoaSDK 

277
00:12:42,176 --> 00:12:44,466
在Swift感觉棒极了 


278
00:12:44,466 --> 00:12:45,536
没有工作。

279
00:12:46,576 --> 00:12:49,906
然而,如果你有objective - c代码

280
00:12:49,906 --> 00:12:51,866
也许你用objective - c代码混合和匹配在你的项目中,


281
00:12:52,206 --> 00:12:54,066
或者你有一个objective - c框架,


282
00:12:54,066 --> 00:12:56,396
你想成为美丽的和可怕的在Swift,


283
00:12:56,396 --> 00:12:58,946
今天迟些时候去其中的一些会议

284
00:12:58,946 --> 00:13:01,316
来了解更多关于这些功能,
这样你就可以提供一个真正伟大的


285
00:13:01,496 --> 00:13:02,206
Swift的经验.


286
00:13:02,296 --> 00:13:04,586
你可能要在视频上看的。

287
00:13:05,146 --> 00:13:07,786
让我们谈谈单元测试。

288
00:13:08,346 --> 00:13:11,806
在整个团队的工具,测试是superimportant。

289
00:13:11,806 --> 00:13:16,006
测试是伟大的在Swift里，直到你把访问控制，

290
00:13:16,566 --> 00:13:18,786
问题是,


291
00:13:18,786 --> 00:13:22,426
Swift公众可见标记符号需要你你的单元测试包


292
00:13:22,726 --> 00:13:25,376
所以你可以测试它们,导致许多东西被公众


293
00:13:25,376 --> 00:13:26,236
真的不应该。

294
00:13:26,686 --> 00:13:29,586
Swift 2 和Xcode 7已经解决了这个问题.


295
00:13:30,286 --> 00:13:32,486
现在你的代码是自动建在一个特殊的模式,


296
00:13:32,786 --> 00:13:35,796
这意味着对你的测试他们可以访问你的公众

297
00:13:35,796 --> 00:13:37,636
默认和内部符号


298
00:13:38,066 --> 00:13:39,676
你必须使用新的应用程序 --


299
00:13:40,516 --> 00:13:44,726
(掌声)


300
00:13:45,226 --> 00:13:46,786
>> CHRIS LATTNER: 这更好的一部分,

301
00:13:46,786 --> 00:13:49,036
它不仅是简单,

302
00:13:49,436 --> 00:13:51,546
也是你仍然得到释放构建正确的行为,


303
00:13:51,586 --> 00:13:52,666
所以你应该得到这个性能


304
00:13:52,666 --> 00:13:55,106
访问控制和保护的好处。


305
00:13:55,606 --> 00:13:57,826
我们有一群讨论测试,

306
00:13:57,826 --> 00:14:00,396
在Xcode UI测试将是一个美妙的谈话。


307
00:14:00,396 --> 00:14:01,156
我强烈推荐它。

308
00:14:01,716 --> 00:14:03,256
让我们谈谈丰富的评论。


309
00:14:04,036 --> 00:14:07,266
操场,他们是好的,Xcode允许您

310
00:14:07,266 --> 00:14:09,676
构建美丽的Swift操场

311
00:14:09,676 --> 00:14:13,586
在编辑器中使用注释的语法,丰富的注释语法。
312
00:14:13,956 --> 00:14:17,176
语法是减价的变体,它是一个伟大的,

313
00:14:17,176 --> 00:14:19,926
众所周知的,非常受欢迎的,喜欢语法。


314
00:14:20,276 --> 00:14:22,096
我们把文档注释，


315
00:14:22,506 --> 00:14:24,416
这意味着您可以构建富有的


316
00:14:24,526 --> 00:14:28,186
和漂亮的美丽的文档注释,

317
00:14:28,446 --> 00:14:30,016
并且为了客户,它显示在你的API。


318
00:14:30,156 --> 00:14:31,316
所以如果你制作一个图书馆,

319
00:14:31,366 --> 00:14:32,546
你可以在这里做更好的事情。

320
00:14:33,636 --> 00:14:35,386
最后，Xcode移居者。


321
00:14:36,046 --> 00:14:38,996
一旦你打开Swift1在Xcode项目7,


322
00:14:38,996 --> 00:14:40,456
它将会提示你说,嘿,

323
00:14:40,726 --> 00:14:42,316
我可以为你Swift2升级。


324
00:14:42,976 --> 00:14:44,336
这需要你通过几个步骤,

325
00:14:44,336 --> 00:14:46,706
你可以选择你的目标,然后给你一个dif。


326
00:14:47,216 --> 00:14:49,606
Swift 2移居者实际上是相当惊人的

327
00:14:49,836 --> 00:14:52,236
它涵盖了绝大多数的问题和情况下，


328
00:14:52,236 --> 00:14:55,516
您将看到2Swift 1到Swift 2,


329
00:14:55,836 --> 00:14:58,506
包括错误处理模型、移动的方法,

330
00:14:58,926 --> 00:15:03,216
改变SDK,大量的选项设置更改,

331
00:15:03,216 --> 00:15:05,636
这些东西都是建立在migrator,


332
00:15:05,636 --> 00:15:07,016
它也是一项伟大的工作。


333
00:15:08,046 --> 00:15:10,736
有大量的新东西在Swift 2中,


334
00:15:10,736 --> 00:15:13,496
我们没有时间谈论现在。

335
00:15:13,496 --> 00:15:14,726
如果您对更多细节感兴趣,


336
00:15:14,726 --> 00:15:17,336
我建议看看快速编程语言的书,


337
00:15:17,336 --> 00:15:18,356
这有一个新版本.


338
00:15:19,196 --> 00:15:21,466
Xcode 7还发布说明更详细地谈到了


339
00:15:21,466 --> 00:15:22,636
很多这些变化l.


340
00:15:23,686 --> 00:15:25,636
现在让我们继续讨论模式匹配.


341
00:15:26,286 --> 00:15:30,726
所以可能你遇到模式匹配的第一个地方是


342
00:15:30,726 --> 00:15:31,846
这个if-let statement.


343
00:15:32,326 --> 00:15:35,936
这是一个伟大的一个可选的方法,


344
00:15:37,296 --> 00:15:39,466
有条件地打开它,然后将这一结果

345
00:15:39,636 --> 00:15:42,096
绑定到一个名称与安全。

346
00:15:42,096 --> 00:15:44,326
他是很好的个东西.


347
00:15:44,326 --> 00:15:46,426
可能有太多的一件伟大的事情,当然.


348
00:15:46,426 --> 00:15:49,636
我们看到的一件事是“金字塔厄运。”


349
00:15:50,156 --> 00:15:52,936
这是会发生什么当你得到太多的如果让所有依偎在一起吗？


350
00:15:52,936 --> 00:15:55,076
突然你的代码是15层深

351
00:15:55,076 --> 00:15:57,526
并且你不能理解它。


352
00:15:57,526 --> 00:15:59,066
Swift 1.2解决了这个问题

353
00:15:59,066 --> 00:16:01,756
通过引入复合条件if语句。

354
00:16:02,066 --> 00:16:03,336
这使得这很自然。.


355
00:16:03,336 --> 00:16:04,966
您可以检查多个可选正确的内联


356
00:16:05,396 --> 00:16:08,996
和布尔条件,而且它很好。

357
00:16:09,546 --> 00:16:11,506
这个不能解决早起退出的问题


358
00:16:12,286 --> 00:16:16,126
我将向您展示一些最可怕的JSON。


359
00:16:16,126 --> 00:16:18,186
你能想到的处理代码。


360
00:16:18,716 --> 00:16:20,846
它会随着时间的推移变得更好.


361
00:16:20,846 --> 00:16:22,356
让我们一起与这个工作


362
00:16:22,356 --> 00:16:23,766
在这里我将各领域的

363
00:16:23,766 --> 00:16:25,216
类型化JSON字典。

364
00:16:25,346 --> 00:16:27,396
所以我退出一个名称,将它转换为字符串,


365
00:16:27,396 --> 00:16:29,726
产生一个可选的,如果它不匹配,我拯救.


366
00:16:30,336 --> 00:16:32,976
同样,拉出,将其转化为一个,


367
00:16:33,016 --> 00:16:34,166
如果不匹配,纾困.


368
00:16:34,696 --> 00:16:36,986
这种模式是很常见的,如果你把大量的值

369
00:16:36,986 --> 00:16:40,686
最好是这样做救助方法

370
00:16:40,686 --> 00:16:42,226
比深深嵌套代码。

371
00:16:43,046 --> 00:16:44,776
这种方法的问题是,


372
00:16:44,806 --> 00:16:48,656
你必须强迫打开当你完成可选值。


373
00:16:49,076 --> 00:16:51,076
在这里我只使用一次,但是如果你有一堆代码使用它们


374
00:16:51,076 --> 00:16:53,946
你力量展开这个无处不在。

375
00:16:53,946 --> 00:16:55,456
你可以做一些事来分解这个，


376
00:16:55,456 --> 00:16:57,696
因此,隐式地打开可选的是一种很好的方式

377
00:16:57,696 --> 00:17:03,736
不安全的因素迫使非覆盖麦加。

378
00:17:04,116 --> 00:17:07,016
这是也许不是正确的方法。


379
00:17:07,016 --> 00:17:08,396
这是丑陋的

380
00:17:08,546 --> 00:17:10,925
我们引入一个新的Guard声明。


381
00:17:11,096 --> 00:17:14,316
看看警卫的方法是确实的检查,


382
00:17:14,316 --> 00:17:17,036
然后包如果检查不匹配。


383
00:17:17,096 --> 00:17:18,856
你可以做很多事情在一个Guard声明中。

384
00:17:18,896 --> 00:17:20,906
我们正在做我们的可选检查。

385
00:17:20,906 --> 00:17:22,626
我们将一个值绑定到一个名称

386
00:17:23,126 --> 00:17:25,016
它工作的方式,它可以工作的方式,

387
00:17:25,066 --> 00:17:29,786
保证你的其他退出当前的范围。

388
00:17:29,786 --> 00:17:33,416
你可以以两种方式,要么回来,扔,
389
00:17:33,416 --> 00:17:36,516
刹车,很多出口范围的方法。

390
00:17:37,796 --> 00:17:38,406
那个是好的


391
00:17:38,656 --> 00:17:42,526
你也可以像No Return function 数前提失败或中止,


392
00:17:42,526 --> 00:17:44,736
这是一个停止的好方法。

393
00:17:45,756 --> 00:17:49,366
这保证编译器,它知道安全性


394
00:17:49,406 --> 00:17:52,596
和确定性的名字注定可以可见

395
00:17:52,596 --> 00:17:54,066
失败的代码之后。

396
00:17:54,746 --> 00:17:57,456
如果我们把我们的例子中,我们的例子会更好


397
00:17:57,566 --> 00:18:00,246
因为现在我们可以使用警卫,我们很安全,


398
00:18:00,346 --> 00:18:03,576
简洁的检查,这是我们所期望的。


399
00:18:04,776 --> 00:18:08,766
另一个优点,这建立在发达、
400
00:18:08,946 --> 00:18:12,376
复合的如果我们有的条件

401
00:18:12,376 --> 00:18:14,656
现在你可以将它们合并在一起并检查复杂的Boolean 


402
00:18:14,656 --> 00:18:17,866
可选的,其他情况下我们会讨论


403
00:18:17,866 --> 00:18:19,526
在你的语句之后.


404
00:18:19,526 --> 00:18:20,886
它真的很好

405
00:18:21,516 --> 00:18:27,616
(掌声)


406
00:18:28,116 --> 00:18:30,596
>> CHRIS LATTNER: 让我们来谈谈更令人兴奋的


407
00:18:30,596 --> 00:18:32,816
和强大的模式匹配,开关。


408
00:18:33,666 --> 00:18:37,476
开关是我想也许别人最喜欢的Swift的特点

409
00:18:37,476 --> 00:18:40,436
因为你可以做那么多模式匹配


410
00:18:40,436 --> 00:18:41,286
在一个switch语句中.


411
00:18:41,626 --> 00:18:43,566
在这你可以检查一个可选的喜欢

412
00:18:43,806 --> 00:18:45,746
你能做的类层次结构检查

413
00:18:45,746 --> 00:18:49,696
可以检查范围,没有结束你能做什么在一个开关。

414
00:18:50,706 --> 00:18:53,616
当你想写很多的情况下,他们是伟大的,


415
00:18:53,696 --> 00:18:55,646
但是他们的语法重量级

416
00:18:55,646 --> 00:18:56,956
当您想要检查一个案例。

417
00:18:56,956 --> 00:18:58,726
们必须详尽,

418
00:18:58,726 --> 00:19:00,716
你必须有一个默认,这是一个痛苦。

419
00:19:00,716 --> 00:19:04,246
我们所做的,我们已经和开关模式匹配的力量

420
00:19:04,666 --> 00:19:06,416
这种情况下

421
00:19:06,416 --> 00:19:08,336
带它到另一个控制语句在语言中

422
00:19:08,786 --> 00:19:12,086
这个例子可以用一个新的情况,检查,


423
00:19:12,086 --> 00:19:13,516
你可以模式匹配


424
00:19:13,516 --> 00:19:15,406
和绑定变量名称正确。


425
00:19:16,516 --> 00:19:20,746
(掌声)


426
00:19:21,246 --> 00:19:22,076
>> CHRIS LATTNER:我们已经走得更远。


427
00:19:22,196 --> 00:19:25,276
另一个伟大的声明Swift…在循环。


428
00:19:25,666 --> 00:19:27,646
所以想要做一些很常见的过滤


429
00:19:27,646 --> 00:19:29,526
在……在循环。


430
00:19:29,526 --> 00:19:30,656
一些语言已经到目前为止


431
00:19:30,656 --> 00:19:32,796
就引入了全新的语言结构


432
00:19:32,796 --> 00:19:35,936
像列表理解模型这种模式。

433
00:19:36,816 --> 00:19:38,006
Swift所做的两件事。


434
00:19:38,256 --> 00:19:39,656
我们增加了能力做一个简单的布尔一个过滤器对内联

435
00:19:39,656 --> 00:19:42,156
做一个简单的布尔一个过滤器对内联


436
00:19:42,156 --> 00:19:43,196
在你……在声明中。

437
00:19:43,906 --> 00:19:47,106
但是你也可以做正确全面模式匹配

438
00:19:47,106 --> 00:19:50,266
在for循环给你强大的条件。

439
00:19:51,516 --> 00:19:55,656
(掌声)


440
00:19:56,156 --> 00:19:57,666
>> CHRIS LATTNER:
我不得不说

441
00:19:57,666 --> 00:19:59,396
关于我们快速模式匹配。

442
00:19:59,726 --> 00:20:01,946
我们谈到了新的Guard声明,这是伟大的Guard


443
00:20:01,946 --> 00:20:03,436
早期退出,

444
00:20:03,436 --> 00:20:06,496
谈到把模式匹配普遍的语言,

445
00:20:06,876 --> 00:20:08,816
和我们不谈论一些其他的改进


446
00:20:08,816 --> 00:20:10,586
你会发现当你开始使用Swift.


447
00:20:11,186 --> 00:20:11,776
谢谢你


448
00:20:11,776 --> 00:20:13,546
我将其移交给约翰,他会告诉你

449
00:20:13,546 --> 00:20:15,076
关于可用性检查。

450
00:20:16,516 --> 00:20:20,946
(掌声)


451
00:20:21,446 --> 00:20:21,876
>> JOHN MCCALL: 谢谢你,克里斯。


452
00:20:23,546 --> 00:20:26,626
我们经常推出新功能,你可能听说过一个叫力量联系


453
00:20:26,626 --> 00:20:28,206
一个叫Force Touch.


454
00:20:30,046 --> 00:20:33,376
Force Touch主要是硬件特性,当然,

455
00:20:33,376 --> 00:20:35,216
它带有一个api的数量


456
00:20:35,216 --> 00:20:36,976
像这样NSButton,


457
00:20:37,456 --> 00:20:43,356
让我改变一个按钮响应拖。

458
00:20:43,356 --> 00:20:46,296
如果我想采用这种在自己的应用程序,


459
00:20:46,896 --> 00:20:48,136
这很容易,对吗?

460
00:20:48,136 --> 00:20:50,516
我必须写一些新的事件处理代码

461
00:20:50,926 --> 00:20:52,516
然后我只需要带我的按钮

462
00:20:52,516 --> 00:20:55,436
并在其上设置这个弹簧属性。

463
00:20:56,236 --> 00:21:00,456
问题是,这可能伟大的在我的开发机器上工作,


464
00:21:00,456 --> 00:21:03,126
但是当我农场我测试硬件,

465
00:21:04,146 --> 00:21:06,266
我要得到一个这样的崩溃几乎可以肯定。


466
00:21:07,006 --> 00:21:10,086
这是因为这是一个新的API。

467
00:21:10,086 --> 00:21:12,156
它介绍了X v10.3。


468
00:21:12,706 --> 00:21:20,266
像你们中的许多人在这种情况下,


469
00:21:20,316 --> 00:21:24,136
你仍然有一个需要支持旧版本的操作系统。


470
00:21:24,136 --> 00:21:28,446
我该如何解决呢?


471
00:21:28,446 --> 00:21:31,056
我过去用这个方法来解决,好吧,

472
00:21:31,056 --> 00:21:34,736
我得到这个错误消息的方法不存在,

473
00:21:34,736 --> 00:21:36,886
让我查一下方法是否存在。

474
00:21:37,846 --> 00:21:39,726
一种方法,有很多不同的习语,


475
00:21:39,726 --> 00:21:42,446
人们开发了这样做,


476
00:21:42,446 --> 00:21:46,386
这是常见的成语,使用响应选择器。


477
00:21:46,806 --> 00:21:50,516
问题是,这是一个紧张,容易出错的模式。

478
00:21:51,306 --> 00:21:57,586
例如,我不得不找出选择器是什么,


479
00:21:57,676 --> 00:22:01,056
从一些Swift语言特性的映射到
一些objective - c选择器


480
00:22:01,056 --> 00:22:05,386 
真的不是那种任何人都应该需要知道的细节


481
00:22:05,386 --> 00:22:06,756
应该需要知道的细节


482
00:22:07,476 --> 00:22:11,336
也是,你知道,没有检查我的编译器


483
00:22:11,336 --> 00:22:14,166
因为我的内在逃离


484
00:22:14,166 --> 00:22:15,546
编译器提供的检查

485
00:22:16,446 --> 00:22:18,806
例如,在这种情况下我已经忘记


486
00:22:18,806 --> 00:22:20,256
添加这个冒号


487
00:22:20,256 --> 00:22:22,696
这意味着检查实际上永远是正确的。


488
00:22:23,426 --> 00:22:25,746
Swift 2中我们有一个更好的解决方案。


489
00:22:26,666 --> 00:22:29,506
默认情况下,编译器检查以确保


490
00:22:29,506 --> 00:22:33,296
你不使用任何api

491
00:22:33,296 --> 00:22:36,936
并没有开放你的最低部署目标。

492
00:22:37,516 --> 00:22:42,546
(掌声)


493
00:22:43,046 --> 00:22:44,016
>> JOHN MCCALL:如果我这样做,

494
00:22:44,016 --> 00:22:45,676
我总是会得到诊断。

495
00:22:46,086 --> 00:22:50,996
是什么,让我有一种安全的核心假设


496
00:22:50,996 --> 00:22:52,466
只要我的代码 --


497
00:22:52,466 --> 00:22:55,786
只要我的项目完全编译,它至少是免费的


498
00:22:55,786 --> 00:22:58,336
这种简单的部署(莫名其妙)。


499
00:22:58,916 --> 00:23:02,256
现在这不是整个兼容性的故事,

500
00:23:02,256 --> 00:23:08,026
当然,但这是一个伟大的方式来帮助你采用新的api。


501
00:23:08,026 --> 00:23:12,646
我想使用这个。

502
00:23:12,736 --> 00:23:13,626
我怎么做?


503
00:23:14,246 --> 00:23:17,716
我们添加了一个新的# availablecondition。


504
00:23:18,536 --> 00:23:23,036
在#可用,你列出你想要的操作系统版本,

505
00:23:23,036 --> 00:23:24,186
以确保您测试。

506
00:23:24,186 --> 00:23:27,076
最后你用这颗恒星,

507
00:23:27,076 --> 00:23:29,686
以确保如果有任何新的OSs


508
00:23:30,616 --> 00:23:32,606
你还没有写这个代码,


509
00:23:32,726 --> 00:23:35,526
你至少得到诊断的可用性。


510
00:23:36,866 --> 00:23:38,596
在这里我使用If语句,


511
00:23:38,596 --> 00:23:40,726
但我可以使用Guard statement


512
00:23:40,726 --> 00:23:42,066
克里斯给我们展示之前。


513
00:23:42,066 --> 00:23:44,746
这是完全相同的逻辑


514
00:23:44,806 --> 00:23:45,716
在所有这些地方的条件。

515
00:23:45,756 --> 00:23:46,606
就这样。

516
00:23:47,416 --> 00:23:49,646
可用性检查。

517
00:23:49,706 --> 00:23:52,776
我们认为这是一个伟大的新方法为了可以接受,


518
00:23:52,776 --> 00:23:54,696
利用新特性的


519
00:23:54,696 --> 00:23:58,306
新操作系统自动和安全在你的项目。


520
00:23:59,076 --> 00:24:01,406
我们将进一步讨论这个在今天晚些时候。

521
00:24:01,406 --> 00:24:03,486
我真的建议你来。

522
00:24:05,456 --> 00:24:08,216
接下来我想谈谈协议扩展。


523
00:24:09,156 --> 00:24:11,866
扩展是一个真正伟大的功能在Swift中.


524
00:24:12,496 --> 00:24:15,186
我可以带一个任意类型数组

525
00:24:15,476 --> 00:24:17,376
并添加自己的方法。


526
00:24:18,126 --> 00:24:23,556
这是并不明显为什么这是一个重要的事情,


527
00:24:23,556 --> 00:24:29,276
但是方法是一个核心部分,


528
00:24:29,276 --> 00:24:31,336
它是该类型的本地api是如何表达。

529
00:24:31,616 --> 00:24:33,176
当我添加一个扩展,

530
00:24:33,176 --> 00:24:36,286
我真的将新功能添加到类型


531
00:24:36,586 --> 00:24:41,786
感觉就像头等舱,正如核心API


532
00:24:41,786 --> 00:24:44,296
的任何类型的设计师


533
00:24:44,296 --> 00:24:45,836
可能已经添加的类型。

534
00:24:46,486 --> 00:24:49,016
这有很多优势。


535
00:24:49,016 --> 00:24:54,536
在这里我已经添加了一个计数方法,

536
00:24:54,536 --> 00:25:00,336
只是为其他数组调用闭包和计数的次数,

537
00:25:00,336 --> 00:25:03,596
返回True。

538
00:25:03,596 --> 00:25:07,176
没有什么在这个方法中,


539
00:25:07,176 --> 00:25:08,006
实际上是特定的阵列。

540
00:25:08,286 --> 00:25:10,646
这应该为任意收集工作

541
00:25:12,116 --> 00:25:16,496
不幸的是,在Swift1我无法表达

542
00:25:16,496 --> 00:25:17,536
这种方法了。

543
00:25:18,126 --> 00:25:20,886
这个通用的对一个任意的集合,


544
00:25:21,226 --> 00:25:23,026
我将不得不写这样的东西。


545
00:25:24,506 --> 00:25:26,296
很多你向我们指出,


546
00:25:26,296 --> 00:25:28,396
这不是最优。


547
00:25:28,906 --> 00:25:32,846
第一件事情是,这是一个许多额外的语法,


548
00:25:32,846 --> 00:25:36,696
有一种失明的尖括号


549
00:25:36,696 --> 00:25:40,046
所有的额外的地壳这个泛型。

550
00:25:41,286 --> 00:25:44,506
第二点是,它不再是一个方法。


551
00:25:45,316 --> 00:25:47,776
因为它不再是一个方法,首先,

552
00:25:47,776 --> 00:25:50,896
这并不像是一个自然的一部分使用的类型。


553
00:25:51,526 --> 00:25:54,106
第二，这是一个发现的。


554
00:25:54,546 --> 00:25:58,136
它不会出现在任何数组,列表的功能


555
00:25:58,476 --> 00:26:01,236
特别地是它不会出现在提供功能的列表中


556
00:26:01,326 --> 00:26:04,176
通过代码自动完成


557
00:26:04,676 --> 00:26:09,796
这意味着好,你写了这个可怕的Count


558
00:26:09,796 --> 00:26:15,196
如果这件事，但没有人使用这个会意识到它的存在,


559
00:26:15,196 --> 00:26:18,986
除非你指出来。


560
00:26:19,186 --> 00:26:19,606
对的


561
00:26:19,606 --> 00:26:20,266
让我们回头看。


562
00:26:20,736 --> 00:26:24,166
我们有这个扩展在数组方法添加到数组中。


563
00:26:24,496 --> 00:26:27,476
为什么我们不能只是延长 -- 我不知道 --


564
00:26:27,586 --> 00:26:30,686
实现集合类型的一切吗?


565
00:26:30,686 --> 00:26:33,426
在Swift 2中,我说现在你可以感到高兴。


566
00:26:34,556 --> 00:26:38,976
你扩展集合类型,而不是扩展数组。


567
00:26:39,626 --> 00:26:40,406
当你做这个的时候，

568
00:26:40,406 --> 00:26:43,676
你是自动添加的方法无处不在


569
00:26:43,676 --> 00:26:46,256
每一个类型实现集合类型,


570
00:26:46,576 --> 00:26:51,036
不仅仅来自标准库或者每一个东西


571
00:26:51,376 --> 00:26:56,456
但即使在你自己的类型,正好符合这一点。


572
00:26:56,456 --> 00:26:59,496
不仅是伟大的编写自己的通用代码,


573
00:26:59,496 --> 00:27:03,026
但我们发现它真的让我们修改很多东西


574
00:27:03,026 --> 00:27:04,606
我们不是很满意的对标准库

575
00:27:04,606 --> 00:27:06,346
对Swift 1的标准库.


576
00:27:07,416 --> 00:27:10,406
在Swift 1中，有很多东西


577
00:27:10,556 --> 00:27:14,456
必须全局函数,因为他们必须通用或者


578
00:27:14,546 --> 00:27:15,996
或者因为我们写通用。

579
00:27:16,746 --> 00:27:19,996
然后更糟糕了, 为了制作我们特殊情况的


580
00:27:19,996 --> 00:27:23,656
特定类型的方法, 像数组


581
00:27:23,656 --> 00:27:25,606
有很多这些地图和筛选方法。


582
00:27:26,096 --> 00:27:29,036
其他类型可能没有。


583
00:27:30,296 --> 00:27:34,706
在Swift 2中,这个功能将是可用的,

584
00:27:34,936 --> 00:27:38,276
这种过滤和地图功能的表达与扩展,


585
00:27:38,276 --> 00:27:42,826
这意味着它可以在每一件事。

586
00:27:42,826 --> 00:27:45,006
它能带来更多的发现,


587
00:27:45,336 --> 00:27:48,466
意味着使用标准库更均匀,

588
00:27:49,046 --> 00:27:51,096
我们真的认为你会喜欢它的。

589
00:27:52,516 --> 00:27:58,026
(掌声)

590
00:27:58,526 --> 00:28:00,946
>> JOHN MCCALL: 我真的还没有进入三分之一的复杂性的

591
00:28:00,946 --> 00:28:05,516
新权力的这个特性。


592
00:28:07,266 --> 00:28:09,366
我们将致力于谈谈这个问题,

593
00:28:09,476 --> 00:28:11,256
明天是一个很好的谈话。


594
00:28:11,736 --> 00:28:14,206
我强烈建议你来。

595
00:28:14,206 --> 00:28:17,506
它是关于伟大的新的设计模式


596
00:28:17,576 --> 00:28:19,386
支持的协议在Swift中.


597
00:28:20,346 --> 00:28:22,376
其余的将是讨论错误处理。


598
00:28:23,286 --> 00:28:25,466
我认为没有人真的喜欢思考


599
00:28:25,466 --> 00:28:26,496
错误处理。


600
00:28:26,496 --> 00:28:32,996
总是这有罪的事情在我们的头脑中


601
00:28:32,996 --> 00:28:36,666
如果你像我一样。


602
00:28:36,666 --> 00:28:38,796
他是真的真的重要的


603
00:28:38,796 --> 00:28:42,516
当我们在看我们能做些什么在Swift中


604
00:28:42,906 --> 00:28:44,966
这将真正使它成为一个更健壮的,

605
00:28:44,966 --> 00:28:48,106
,更富有表现力的语言,我们说,好吧,


606
00:28:48,106 --> 00:28:50,126
这里最重要的事情

607
00:28:50,126 --> 00:28:54,036
做一些关于错误处理。


608
00:28:54,036 --> 00:28:58,706
当我们看着的解决方案,


609
00:28:58,706 --> 00:29:00,306
在其他语言中,在Cocoa,


610
00:29:00,306 --> 00:29:03,186
我们真的不满意对他们。


611
00:29:03,186 --> 00:29:06,876
他们都有重大缺陷

612
00:29:06,876 --> 00:29:08,266
我们真得不喜欢


613
00:29:09,316 --> 00:29:10,926
他们中的一些人,你知道,


614
00:29:10,926 --> 00:29:13,966
是基于传播错误自动


615
00:29:13,966 --> 00:29:16,086
像NSError objective - c,


616
00:29:16,396 --> 00:29:19,846
什么是创造大量重复出错的代码,

617
00:29:19,846 --> 00:29:20,696
你最终不得不重复的逻辑的到处都是

618
00:29:20,696 --> 00:29:23,736
不得不重复的逻辑的到处都是


619
00:29:24,006 --> 00:29:26,566
这意味着它很容易出错。

620
00:29:26,896 --> 00:29:29,606
更重要的是,当你自己周围传播错误值,


621
00:29:29,606 --> 00:29:34,796
隐式的默认行为


622
00:29:34,796 --> 00:29:36,546
是你忽略的错误。

623
00:29:37,086 --> 00:29:39,146
这只是永远正确的默认。

624
00:29:39,436 --> 00:29:42,276
你应该考虑至少有点错误。


625
00:29:43,276 --> 00:29:45,456
在光谱的另一端,


626
00:29:45,516 --> 00:29:48,376
有传播错误在隐式的语言,

627
00:29:48,916 --> 00:29:50,316
与异常处理。


628
00:29:50,366 --> 00:29:52,946
但是我们不喜欢的工作。


629
00:29:52,946 --> 00:29:58,686
有太多这是隐式的,它不太容易


630
00:29:58,686 --> 00:30:01,626
不去想再次犯错误,和你最终的陷阱,

631
00:30:01,626 --> 00:30:06,566
你只是不明白可能出错


632
00:30:06,566 --> 00:30:07,286
在你的项目中。


633
00:30:07,486 --> 00:30:10,786
你不懂如何控制能流


634
00:30:10,786 --> 00:30:12,056
从一个地方到另一个地方


635
00:30:12,576 --> 00:30:16,106
再一次,这不是一个安全、可靠的编程模型。


636
00:30:16,636 --> 00:30:22,426
有三种不同的方式,函数可以失败。


637
00:30:23,796 --> 00:30:27,786
方法之一是,他们可以简单地-- 
很多功能只是失败


638
00:30:27,786 --> 00:30:32,486
在一个相当简单的,天生的,明显的方式中。

639
00:30:32,986 --> 00:30:35,016
例如,除非您正在运行一个编译器,

640
00:30:35,086 --> 00:30:38,526
你可能不在乎为什么解析一个整数


641
00:30:38,526 --> 00:30:41,236
的字符串失败了,这并不是要

642
00:30:41,236 --> 00:30:43,936
你得到的多汁的细节的东西


643
00:30:43,936 --> 00:30:45,276
和报告给用户。


644
00:30:45,556 --> 00:30:48,016
可能你想直接处理。


645
00:30:48,786 --> 00:30:51,126
这就已经不错了,当我们看着它,

646
00:30:51,256 --> 00:30:53,826
t这是已经在Swift处理得非常好


647
00:30:53,896 --> 00:30:55,676
仅仅这些可选的结果。


648
00:30:56,246 --> 00:30:58,146
我们不认为我们需要在这里做任何事。

649
00:30:58,146 --> 00:31:00,066
我们真的已经满意,是如何工作的。

650
00:31:00,526 --> 00:31:04,006
在光谱的另一端,有很多事情是程序员的逻辑失败

651
00:31:04,006 --> 00:31:06,786
是程序员的逻辑失败


652
00:31:07,126 --> 00:31:09,996
在你的程序错误中,断言,


653
00:31:10,736 --> 00:31:14,326
索引界外,绝大多数人使用的方法



654
00:31:14,326 --> 00:31:18,616
n NSException,这一类的事情。

655
00:31:18,806 --> 00:31:21,276
对于这些事情,实际上他们真的不


656
00:31:21,336 --> 00:31:22,306
可能恢复

657
00:31:22,656 --> 00:31:25,026
当你可以摆脱这种事情,

658
00:31:25,026 --> 00:31:30,366
你只是促进整体不稳定程序。


659
00:31:30,656 --> 00:31:33,676
你不知道国家程序实际上是

660
00:31:33,676 --> 00:31:37,166
在如果你随机从索引中恢复过来的。


661
00:31:37,566 --> 00:31:39,956
您甚至可以创建


662
00:31:39,956 --> 00:31:40,956
您的应用程序的安全问题。

663
00:31:41,516 --> 00:31:48,646
在中间,有这种大范围的api


664
00:31:48,646 --> 00:31:51,606
能不能在一个非常丰富的方式。


665
00:31:52,356 --> 00:31:54,276
这真的是我们想要关注的。


666
00:31:54,576 --> 00:31:58,296
今天的事情你的可可会使用NSError。


667
00:31:58,296 --> 00:32:03,506
我想通过一个例子给你。

668
00:32:03,686 --> 00:32:05,926
这是一个起飞前的方法,我想我有


669
00:32:05,926 --> 00:32:09,086 
一些操作”,以确保它的工作原理。


670
00:32:09,126 --> 00:32:11,966
我认为这是之前你所写的

671
00:32:12,586 --> 00:32:15,546
我将检查是否一些文件实际上是可获得的,


672
00:32:15,546 --> 00:32:18,396
然后我要重置一些


673
00:32:18,446 --> 00:32:20,556
与国家相关的操作。


674
00:32:20,676 --> 00:32:23,396
现在是否可以检查资源,

675
00:32:23,396 --> 00:32:25,616
这是一个会失败的操作。


676
00:32:25,986 --> 00:32:28,036
它可以以各种各样的方式失败。


677
00:32:28,036 --> 00:32:30,426
应该报告的东西回来,因为,嘿,


678
00:32:30,856 --> 00:32:32,786
有人说这真的

679
00:32:32,786 --> 00:32:35,266
可能想知道为什么不可以

680
00:32:35,496 --> 00:32:38,086
也许不同的方式探讨它取决于不同的原因。


681
00:32:38,656 --> 00:32:45,316
如果我想使用NSError,

682
00:32:45,316 --> 00:32:46,836
这是种什么代码会变成什么样子。


683
00:32:47,206 --> 00:32:50,916
我把这个错误,我传播到调用者。

684
00:32:52,496 --> 00:32:56,206
有些东西喜欢这一点。


685
00:32:56,206 --> 00:32:58,296
有很多事情我们真的不喜欢。

686
00:32:59,346 --> 00:33:02,436
它会带来很多样板到我的逻辑


687
00:33:02,996 --> 00:33:08,356
我有一个紧凑的小两行功能,现在变成了这样


688
00:33:08,356 --> 00:33:10,916
-- 你知道,这个如果语句,额外的嵌套,


689
00:33:10,916 --> 00:33:13,016
额外的嵌套,额外的参数,


690
00:33:13,016 --> 00:33:16,336
这里有很多,


691
00:33:16,336 --> 00:33:18,516
其唯一目的是表达这有一个错误,


692
00:33:18,746 --> 00:33:22,366
我们传播给调用者。


693
00:33:22,366 --> 00:33:28,016
更糟糕的是,又一次,这里有一个会议,

694
00:33:28,596 --> 00:33:30,666
这是一个会议你需要知道。


695
00:33:30,666 --> 00:33:33,416
这是一个会议你必须手动执行,


696
00:33:33,416 --> 00:33:36,866
编译器并不是真的会帮助你。


697
00:33:37,336 --> 00:33:40,506
再一次,我在这里犯了一个错误。


698
00:33:40,976 --> 00:33:44,896
当你返回False,该公约是一个错误


699
00:33:44,896 --> 00:33:48,026
我真的检查错误的方式。


700
00:33:48,386 --> 00:33:50,546
我不知道为什么他们信任我,

701
00:33:50,546 --> 00:33:51,296
甚至使用编译器[笑]。


702
00:33:54,136 --> 00:33:55,936
我在这里需要添加这不是


703
00:33:55,936 --> 00:33:57,146
为了得到我想要的行为


704
00:33:58,426 --> 00:34:01,186
好吧。那是,不,对不起。


705
00:34:02,446 --> 00:34:03,786
这些都是不利的


706
00:34:03,786 --> 00:34:05,956
实际上是有很多,我们喜欢它。

707
00:34:07,446 --> 00:34:10,976
第一件事是,它是明显的从阅读这段代码


708
00:34:11,396 --> 00:34:14,966
检查资源可及是可以失败。


709
00:34:15,226 --> 00:34:17,476
它说在这个名字,它谈到了错误,


710
00:34:17,795 --> 00:34:19,666
它有明确的错误处理的事情,


711
00:34:19,936 --> 00:34:21,596
这种明确的错误参数.


712
00:34:22,735 --> 00:34:24,766
同样,这是显而易见的


713
00:34:24,766 --> 00:34:26,985
起飞前的一个操作,可以失败.


714
00:34:27,206 --> 00:34:31,426
再次明确误差参数,返回值,等等

715
00:34:32,676 --> 00:34:36,826
第三件事是,没有隐式的控制流。

716
00:34:37,716 --> 00:34:40,396
我可以看看这事和理解


717
00:34:41,596 --> 00:34:43,025
所有的跳跃

718
00:34:43,456 --> 00:34:48,065
我可以静态地分析我的代码作为一个人类,而不是作为一个编译器。

719
00:34:48,226 --> 00:34:51,036
作为一个人类,我可以看看这段代码和理性。

720
00:34:51,036 --> 00:34:53,126
它是不需要


721
00:34:53,126 --> 00:34:54,886
知道每一个细节


722
00:34:54,886 --> 00:34:59,606
我打电话的每一个函数。


723
00:34:59,746 --> 00:35:00,026
对的


724
00:35:00,706 --> 00:35:01,936
现在让我们回到这个例子。


725
00:35:02,076 --> 00:35:03,346
这就是它之前看出来的。


726
00:35:04,316 --> 00:35:07,026
会发生什么如果我尝试编译这个在Swift中?


727
00:35:07,436 --> 00:35:10,846
我将得到一个错误消息

728
00:35:10,906 --> 00:35:12,376
因为我不是处理错误。


729
00:35:13,876 --> 00:35:20,166
有两个组件在处理错误在Swift中.


730
00:35:20,976 --> 00:35:23,906
第一,当你调用的API


731
00:35:23,906 --> 00:35:26,726
以失败,你必须使用这个关键字试试。

732
00:35:27,526 --> 00:35:30,986
试着沟通,真的很主要


733
00:35:30,986 --> 00:35:32,256
对于某人来说阅读代码。


734
00:35:32,466 --> 00:35:36,186
它传达给你,嘿,这是可以失败的，


735
00:35:36,576 --> 00:35:37,946
这意味着当你回来的时候,

736
00:35:37,946 --> 00:35:40,026
当你保持这样的在以后,

737
00:35:40,386 --> 00:35:42,786
我马上就知道--


738
00:35:43,656 --> 00:35:46,526
复位状态,不一定

739
00:35:46,526 --> 00:35:49,246
要每次都被称为这个函数


740
00:35:49,636 --> 00:35:51,726
这可能是一个对我来说真正重要的事情。


741
00:35:52,076 --> 00:35:55,616
当我首先写这段代码,


742
00:35:55,616 --> 00:35:56,586
这是我思考的东西


743
00:35:56,866 --> 00:36:01,466
嘿,重置状态应该叫我每一次都


744
00:36:01,466 --> 00:36:01,956
退出函数吗


745
00:36:02,646 --> 00:36:03,766
起飞前的操作吗?


746
00:36:03,766 --> 00:36:07,656
也许吧。仅此还不够,


747
00:36:07,656 --> 00:36:10,026
实际上我不以任何方式处理错误。

748
00:36:10,416 --> 00:36:15,116
这是因为在Swift中,默认情况下,函数不能丢


749
00:36:16,096 --> 00:36:19,516
那实际上是一个核心的我们设计的方面


750
00:36:20,996 --> 00:36:23,986
因为这意味着什么是错误是有界的。


751
00:36:24,546 --> 00:36:27,846
你不必考虑字面上一切能够


752
00:36:27,846 --> 00:36:30,466
抛出异常喜欢它可以在Java或c#


753
00:36:30,556 --> 00:36:32,946
或基本上每个语言使用异常.


754
00:36:34,856 --> 00:36:39,036
相反,它只是非常具体的东西


755
00:36:39,036 --> 00:36:42,076
你知道你需要担心他们是否能扔掉.


756
00:36:42,266 --> 00:36:43,846
当你在代码中调用它们,


757
00:36:43,846 --> 00:36:45,386
它总是要试一试。


758
00:36:45,666 --> 00:36:49,006
结合大量通信。


759
00:36:49,266 --> 00:36:51,376
好吧。假设我想只是


760
00:36:51,376 --> 00:36:53,356
传播错误对我的调用者。



761
00:36:53,906 --> 00:36:57,386
为了做到这一点,所有我要做的就是告诉编译器,嘿,


762
00:36:57,386 --> 00:37:00,036
这是这件事可以抛出的错误。

763
00:37:00,716 --> 00:37:02,486
我抛出这样做


764
00:37:03,156 --> 00:37:05,946
这也许不是我想处理这个问题。


765
00:37:06,086 --> 00:37:07,816
这是一个起飞前的操作。


766
00:37:08,066 --> 00:37:11,826
我可能想吞下犯下的错误


767
00:37:11,826 --> 00:37:14,096
并告诉谁叫我

768
00:37:14,096 --> 00:37:15,476
是否起飞前的成功了。


769
00:37:16,576 --> 00:37:18,436
为此,我必须处理它。


770
00:37:18,436 --> 00:37:21,156
我处理它通过写这个 Do Catch.


771
00:37:22,496 --> 00:37:26,946
在做任何的代码,其中出现的任何错误,


772
00:37:26,946 --> 00:37:30,226
转发,透过所有的捕获。


773
00:37:31,256 --> 00:37:33,786
那么后一个问题,

774
00:37:34,726 --> 00:37:36,426
什么,你可以写在一个开关。


775
00:37:36,756 --> 00:37:41,526
整个的力量Swift的模式匹配语法


776
00:37:41,526 --> 00:37:44,266
有一个问题


777
00:37:44,436 --> 00:37:47,656
一个非常简单的、常见的句法细化

778
00:37:48,046 --> 00:37:54,306
抓住就像这是一个简称捕捉它


779
00:37:54,306 --> 00:37:58,326
和绑定这个特殊的误差变量。


780
00:37:58,326 --> 00:38:00,616
我也可以写一个更复杂的事情。


781
00:38:00,616 --> 00:38:04,826
例如,我可能想要治疗某些类型的错误


782
00:38:05,326 --> 00:38:10,556
作为特殊的,也许他们可以接受我在起飞前的。


783
00:38:10,666 --> 00:38:13,646
我不知道为什么这个文件不存在就好了,


784
00:38:13,646 --> 00:38:18,456
也许我真的想检查如果它存在,你知道,


785
00:38:18,496 --> 00:38:21,586
实际上并不是用于某些权限的原因。


786
00:38:21,956 --> 00:38:28,446
如果我想,我可以对错误代码模式匹配

787
00:38:28,446 --> 00:38:34,326
这样的直接和域。


788
00:38:34,536 --> 00:38:38,616
说句题外话,有三分之一的方式处理错误。


789
00:38:39,296 --> 00:38:43,916
它经常发生,你设置先决条件


790
00:38:44,416 --> 00:38:47,526
你知道一个特定的电话

791
00:38:47,526 --> 00:38:52,096
实际上,正式得不能被扔。

792
00:38:52,096 --> 00:38:55,476
例如,也许这个文件实际上是在我的应用程序包


793
00:38:55,796 --> 00:39:02,736
我知道,如果我不能在自己的应用程序读取一个文件包,


794
00:39:03,026 --> 00:39:04,716
一些事真得，真得，是错的


795
00:39:04,926 --> 00:39:07,336
可能没有真正的恢复方法。


796
00:39:08,386 --> 00:39:10,016
这种常见的模式,


797
00:39:10,016 --> 00:39:11,686
你真的想要一个致命错误吗


798
00:39:11,686 --> 00:39:14,386
因为是抛出一个错误,


799
00:39:14,926 --> 00:39:20,386
它有一个非常紧凑语法与之关联,这个试试!


800
00:39:20,616 --> 00:39:25,186
这一切真的是创建一个断言代码

801
00:39:25,186 --> 00:39:29,606
在尝试实际上并不抛出。

802
00:39:29,946 --> 00:39:32,346
如果是这样,你的程序会崩溃

803
00:39:32,346 --> 00:39:33,806
就像任何形式的断言失败。



804
00:39:34,466 --> 00:39:36,806
这是,你可以调试，非常的容易。


805
00:39:37,606 --> 00:39:39,426
这并不是您一直想要使用的东西,


806 
00:39:39,586 --> 00:39:44,826
但是当你需要它时,它是真的,真的很方便。


807
00:39:44,896 --> 00:39:47,536
回去。


808
00:39:47,756 --> 00:39:48,626
我发现一个错误。


809
00:39:49,546 --> 00:39:51,386
什么样的事情是一个错误吗?。


810
00:39:52,506 --> 00:39:54,676
嗯,我们有一个建成的

811
00:39:54,676 --> 00:40:00,566
协议标准库称为ErrorType

812
00:40:00,896 --> 00:40:05,916
你可以把任何类型的值符合ErrorType


813
00:40:06,596 --> 00:40:07,886
当你发现一些东西,


814
00:40:09,046 --> 00:40:10,786
那件事你模式匹配


815
00:40:10,786 --> 00:40:13,836
是ErrorType的任意值。

816
00:40:14,266 --> 00:40:15,966
我们认为这是非常重要的

817
00:40:16,006 --> 00:40:22,076
我们不更精确地跟踪错误

818
00:40:22,076 --> 00:40:23,396
而是是否被抛出一个错误。


819
00:40:23,396 --> 00:40:27,086
它不像Java,最终你会得到一个迂腐


820
00:40:27,086 --> 00:40:29,986
的每一个例外列表可能已经出局了


821
00:40:29,986 --> 00:40:32,736
然后你终止真正复杂的传播

822
00:40:32,736 --> 00:40:34,456
你每次改变错误的问题。

823
00:40:36,016 --> 00:40:40,456
只是跟踪是否可以抛出一个错误通常

824
00:40:40,456 --> 00:40:41,636
是足够好,几乎总是


825
00:40:42,016 --> 00:40:43,236
我们认为这是一个伟大的榜样。


826
00:40:43,806 --> 00:40:47,626
你可以让你自己的类型符合ErrorType


827
00:40:47,626 --> 00:40:50,496
这是一个过程,是一个

828
00:40:50,496 --> 00:40:52,326
比Cocoa容易得多的.


829
00:40:53,896 --> 00:40:56,826
枚举是一个伟大的方式表达。


830
00:40:57,426 --> 00:41:00,496
他们是一个伟大的方式来表达一组相关的问题,

831
00:41:00,876 --> 00:41:04,896
和他们一样――你知道,这是尤其如此

832
00:41:04,896 --> 00:41:10,176
因为你可以关联数据伴随着每一个案例通过枚举


833
00:41:10,176 --> 00:41:12,346
如果我想报告更丰富和可能的错误消息

834
00:41:12,576 --> 00:41:15,256
和可能的错误消息 --


835
00:41:15,256 --> 00:41:18,286
也许我检查一些无效的状态


836
00:41:18,286 --> 00:41:20,086
我想记住无效的状态是什么,


837
00:41:20,436 --> 00:41:25,046
我可以直接嵌入,枚举作为一个相关值


838
00:41:25,046 --> 00:41:28,306
在特定情况下


839
00:41:28,506 --> 00:41:32,116
所有您需要做的是为了让一个可用的枚举

840
00:41:32,876 --> 00:41:35,406
作为误差使其符合ErrorType。

841
00:41:35,816 --> 00:41:38,596
编译器自动处理

842
00:41:38,596 --> 00:41:39,506
合成的细节。

843
00:41:39,996 --> 00:41:42,686
这是比创建一个新的NSError的过程域和关联的事情。

844
00:41:42,686 --> 00:41:46,516
新的NSError的过程域和关联好的事情。


845
00:41:46,516 --> 00:41:48,986
我们认为,这将真正帮助你造就伟大的,


846
00:41:48,986 --> 00:41:52,156
表达的error-throwing api


847
00:41:52,156 --> 00:41:53,996
当您需要在您自己的代码。


848
00:41:57,716 --> 00:42:00,696
让我们回到这个例子之前,克里斯，


849
00:42:00,696 --> 00:42:03,216
这个JSON处理器。


850
00:42:04,326 --> 00:42:07,286
在这里我也返回到一个错误使用类型


851
00:42:07,286 --> 00:42:07,776
在这字符串中


852
00:42:09,156 --> 00:42:11,896
让我们做这看起来更像是在Swift.


853
00:42:12,926 --> 00:42:15,976
第一件事,而不是字符串,


854
00:42:16,236 --> 00:42:21,326
我将使用enum数据错误，我只是谈论

855
00:42:22,776 --> 00:42:25,716
我只需要,使用新的语句,


856
00:42:25,716 --> 00:42:28,126
以便扔掉这些值,这只是工作。

857
00:42:29,166 --> 00:42:30,896
另一边,当然,是我需要

858
00:42:30,896 --> 00:42:32,226
改变返回类型


859
00:42:32,226 --> 00:42:34,116
我也不再返回一个类型。

860
00:42:34,486 --> 00:42:37,006
这并不是每一个调用者

861
00:42:37,006 --> 00:42:40,446
必须认真进行微观管理的返回值,

862
00:42:40,446 --> 00:42:42,116
以检查错误。

863
00:42:43,486 --> 00:42:47,006
我只是改变它,这样它返回的人


864
00:42:47,576 --> 00:42:50,506
也是一个投掷方法,然后我


865
00:42:50,506 --> 00:42:54,476
没有将时间浪费在这些小细节。


866
00:42:54,696 --> 00:42:56,536
让我们做一个新的例子,

867
00:42:56,576 --> 00:43:00,756
精心挑选了我们刚刚创建的方法。


868
00:43:00,756 --> 00:43:05,336
我们解析,解析JSON的片段,我们出一个人。


869
00:43:06,236 --> 00:43:11,106
现在我们将使用,整个销售记录包括解析出来。


870
00:43:11,106 --> 00:43:16,466
那个人和一些物品。


871
00:43:17,666 --> 00:43:25,296
有时发生,你需要,你知道,


872
00:43:25,296 --> 00:43:26,196
这是有点做作的例子

873
00:43:26,266 --> 00:43:31,176
对不起。有时我想观察这种过程。


874
00:43:31,176 --> 00:43:35,966
我要有某种形式的代表,我要让它知道

875
00:43:35,966 --> 00:43:38,076
我开始读一个销售记录。

876
00:43:38,076 --> 00:43:42,456
我已经告诉它我开始阅读,


877
00:43:42,746 --> 00:43:45,646
显然,我应该告诉它我已经读完了。


878
00:43:45,646 --> 00:43:49,616
我可以添加下面的代码。


879
00:43:49,616 --> 00:43:53,996
问题是我什么都没做的不正确

880
00:43:54,106 --> 00:43:55,016
伴随着错误处理。

881
00:43:55,366 --> 00:43:57,766
这是对所有这些,就像真的容易--


882
00:43:57,866 --> 00:44:01,186
实际上，如果我代表小心和变异


883
00:44:01,186 --> 00:44:04,736
必然建立在每一个时间
 --


884
00:44:05,226 --> 00:44:08,036
当拍卖结束时调用。


885
00:44:08,546 --> 00:44:11,196
如果我委托方差要


886
00:44:11,196 --> 00:44:14,526
保持呼吁两端, 


887
00:44:14,526 --> 00:44:16,296
如果我真的失败了，我将混乱过程。

888
00:44:16,706 --> 00:44:18,826
这是一种问题,出现很多,


889
00:44:18,926 --> 00:44:22,286
使错误处理显得如此脆弱。

890
00:44:23,696 --> 00:44:27,176
好吧。当然,一个方法我可以解决这个

891
00:44:27,286 --> 00:44:33,846
是,我只需将我的电话结束


892
00:44:33,846 --> 00:44:36,366
阅读销售这两个把网站上,然后,当然,


893
00:44:36,366 --> 00:44:39,836
我仍然没有处理该调用过程的人。


894
00:44:39,876 --> 00:44:42,856
为了做一些事情,我必须添加该做的。

895
00:44:43,976 --> 00:44:47,556
这是一个真的,真的――一个,这是令人难以置信的详细。


896
00:44:47,556 --> 00:44:50,376
但也很容易出错,因为这对我来说很容易添加新代码

897
00:44:50,376 --> 00:44:53,416
新类型的处理

898
00:44:53,726 --> 00:44:56,416
之后,它立刻就会过时

899
00:44:56,416 --> 00:44:57,896
如果我真的做点什么。


900
00:44:58,546 --> 00:45:02,756
如果我忘记添加了阅读结束销售


901
00:45:02,936 --> 00:45:04,646
沿着特定路径。


902
00:45:06,366 --> 00:45:08,486
Swift 2有一个更好的选择。


903
00:45:09,026 --> 00:45:11,466
它被称为延迟。


904
00:45:13,656 --> 00:45:16,766
一个推迟语句创建一个行动。


905
00:45:17,656 --> 00:45:21,886
当你执行它,这一行动


906
00:45:21,886 --> 00:45:25,956
无论多么执行当前的范围了。


907
00:45:27,096 --> 00:45:30,976
如果我回来,如果我放弃它,如果我抛出


908
00:45:30,976 --> 00:45:32,736
一个错误,无论如何,


909
00:45:33,676 --> 00:45:36,276
我知道那件事会被执行。


910
00:45:37,436 --> 00:45:40,066
这意味着,作为一个阅读这段代码,


911
00:45:40,476 --> 00:45:41,916
维护这段代码,

912
00:45:42,216 --> 00:45:46,876
我觉得完全有信心并将执行结束


913
00:45:46,876 --> 00:45:51,426
阅读销售无论我做什么,读完。



914
00:45:52,006 --> 00:45:54,636
这是一个非常有价值的事情。


915
00:45:55,516 --> 00:46:06,696
(掌声)


916
00:46:07,196 --> 00:46:09,426
>> JOHN MCCALL:我想要一个快速的比较关于执行。

917
00:46:10,266 --> 00:46:14,946
你们中的一些人习惯于异常处理可能意识到

918
00:46:14,946 --> 00:46:18,306
异常处理在许多语言中实现的

919
00:46:18,306 --> 00:46:21,196
方式非常、非常高得偏见

920
00:46:21,276 --> 00:46:23,456
对实际上反对抛出错误。

921
00:46:23,956 --> 00:46:29,116
它通常是三个,甚至四个数量级速度较慢

922
00:46:29,396 --> 00:46:34,306
返回的一个函数,把一个错误


923
00:46:34,356 --> 00:46:38,386
比仅仅返回正常的方式简单。

924
00:46:38,506 --> 00:46:42,696
现在,需要的一些设计方面的语言。


925
00:46:42,826 --> 00:46:46,496
它不是真正的我们想要的东西在Swift模仿。


926
00:46:47,056 --> 00:46:50,706
你真正需要知道的是,这里的迅速实现更平衡,

927
00:46:50,706 --> 00:46:54,546
这里的Swift实现更好平衡一些,

928
00:46:55,326 --> 00:46:59,206
更像,基本上,一个If语句的调用者。

929
00:46:59,696 --> 00:47:02,926
这意味着它不是完全免费,以调用的东西


930
00:47:02,926 --> 00:47:03,866
可以抛出一个错误。


931
00:47:03,866 --> 00:47:06,916
但这意味着您不需要担心


932
00:47:06,916 --> 00:47:11,836
我们的错误处理功能变得这么贵，

933
00:47:11,836 --> 00:47:16,946
你不能使用它为了实际的原因,


934
00:47:16,946 --> 00:47:19,096
你需要如果你需要关心


935
00:47:19,096 --> 00:47:22,366
错误路径的效率。


936
00:47:24,816 --> 00:47:27,756
最后,我只是想指出,Swift,


937
00:47:28,356 --> 00:47:31,426
Swift的错误处理设计作品

938
00:47:31,626 --> 00:47:32,616
精美Cocoa api


939
00:47:33,926 --> 00:47:38,556
我们自动识别最常见的惯例


940
00:47:38,616 --> 00:47:39,696
在Cocoa中.


941
00:47:39,696 --> 00:47:44,926
例如,有一个NSError参数的方法


942
00:47:44,926 --> 00:47:48,496
并返回保龄球自动成为投掷的方法

943
00:47:48,496 --> 00:47:50,466
和保龄球返回值消失。

944
00:47:51,366 --> 00:47:55,826
同样如果它返回一个可选的结果 we recognize


945
00:47:55,826 --> 00:48:00,166
我们认识到模式零显示无效的事情,


946
00:48:00,716 --> 00:48:06,786
它不再返回一个可选的结果,因为零,


947
00:48:06,786 --> 00:48:09,466
当然是包含在错误处理。


948
00:48:10,516 --> 00:48:14,846
(掌声)

949
00:48:15,346 --> 00:48:18,506
>> JOHN MCCALL:我们发现与这两个非常简单的规则


950
00:48:18,506 --> 00:48:22,666
巨大得,绝大多数的api系统中导入

951
00:48:22,936 --> 00:48:26,436
并自动使用这个新的Swift无缝地错误处理模型

952
00:48:26,846 --> 00:48:30,396
和美丽的,我们认为这是一个伟大的新方式


953
00:48:30,396 --> 00:48:35,086
在Swift处理错误。

954
00:48:35,086 --> 00:48:37,336
我真的强烈建议你看看这个。


955
00:48:37,456 --> 00:48:39,226
你可能真的没有太多的选择,

956
00:48:39,296 --> 00:48:41,006
他们在每一个地方[笑]。


957
00:48:44,586 --> 00:48:47,066
>> JOHN MCCALL: 你知道,我们真的感到自豪的关于这个设计。


958
00:48:47,386 --> 00:48:50,886
我们认为这将大大提高鲁棒性


959
00:48:51,156 --> 00:48:52,906
和编写代码的表现力


960
00:48:53,146 --> 00:48:56,566
和让你设计你自己的api,相当多的工作。


961
00:48:57,126 --> 00:48:59,576
让我来总结。


962
00:48:59,576 --> 00:49:04,196
我们一直在Swift 2工作确实很难,


963
00:49:04,376 --> 00:49:07,506
给你一个新的语言,真正充实核心编程的各个方面迅速、


964
00:49:07,506 --> 00:49:13,376
真正充实核心编程的各个方面在Swift中,


965
00:49:13,596 --> 00:49:17,546
使用工具在Swift中,给你一个更安全的,


966
00:49:17,636 --> 00:49:22,626
更健壮的环境,一般做伟大的事情。


967
00:49:24,596 --> 00:49:27,946
一个宝贵的工具对我们来说,在这整个时间,

968
00:49:28,326 --> 00:49:29,666
你的反馈。

969
00:49:30,126 --> 00:49:31,896
我们真得，真得，很欣赏它


970
00:49:32,126 --> 00:49:33,536
我们正在听的,我保证。


971
00:49:35,546 --> 00:49:37,886
如果你有事情要对我们说,


972
00:49:38,246 --> 00:49:40,916
当然您可以简单地使用错误的记者

973
00:49:41,276 --> 00:49:47,066
但是你也可以邮件Stefan较小,dev论坛,


974
00:49:47,066 --> 00:49:49,056
我们大多数人都在那儿。

975
00:49:49,346 --> 00:49:51,816
我们非常乐意回答任何问题,


976
00:49:52,136 --> 00:49:53,516
听到你的反馈.


977
00:49:53,846 --> 00:49:55,896
我们真的,真的值。


978
00:49:57,116 --> 00:49:59,836
非常感谢你[掌声].


979
00:50:03,106 --> 00:50:04,966
有一个伟大的WWDC 2015。

980
00:50:05,516 --> 00:50:18,270
(掌声)

